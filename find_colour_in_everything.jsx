/* ----------------------------------------------------------------------------------Suche Farbe in allemDescription:Sucht nach einer gewählten Farbe in fast allen Attributen in allen Objekten[Ver. 1.2]  [Autor: Gerald Singelmann. ] [Lang: DE]  [Getestet mit: InDesign CC2019]  [Mod: 19-08-13]Bugs & Feedback : gerald{at}cuppascript{dot}com  www.cuppascript.com   ---------------------------------------------------------------------------------- */ if (app.documents.length > 0) {	app.doScript( main, undefined, undefined, UndoModes.ENTIRE_SCRIPT, "Finde Farbe..." );}function main() {	var doc = app.activeDocument;	var a_dialog = app.dialogs.add({name:"Welche Farbe suchen Sie?"});	with (a_dialog) {		with (dialogColumns.add()) {			with (dialogRows.add() ) {				var dropdown_choices = doc.swatches.everyItem().name;				staticTexts.add( {staticLabel: "gesuchtes Farbfeld"} );				var the_dropdown = dropdowns.add({ stringList: dropdown_choices, selectedIndex: 2});			}		}	}	if (a_dialog.show() == false) {		a_dialog.destroy();		exit();	} else {		var the_swatch = doc.swatches[ (the_dropdown.selectedIndex) ];	}	var prev_ruler = doc.viewPreferences.rulerOrigin;	doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;	var all_things = new Array();	for (var s = 0; s < doc.spreads.length; s++) {		var things = get_things(the_swatch, doc.spreads[s], s);		for (var t = 0; t < things.length; t++) {			all_things.push(things[t]);		}	}	things = get_texts( the_swatch );	for (var t = 0; t < things.length; t++) {		all_things.push(things[t]);	}		if (all_things.length > 0) {		var layer = doc.layers.item("gefundene Farbe");		if (layer.isValid == false) {			layer = doc.layers.add({name: "gefundene Farbe"});			layer.move( LocationOptions.AT_BEGINNING );		}		var swatch = doc.swatches.item("gefundene Farbe Indikator");		if (swatch.isValid == false) {			swatch = doc.colors.add({ name: "gefundene Farbe Indikator", colorModel: ColorModel.PROCESS, space: ColorSpace.RGB, colorValue: [255, 33,33] } );		}		for (var t = 0; t < all_things.length; t++) {			indicate_object(all_things[t], layer, swatch);		}	} else {		alert ("nix gefunden");	}	  	doc.viewPreferences.rulerOrigin = prev_ruler;}function get_texts( swatch ) {	var frames = new Array();	var tframes = new Array();	var spread;	find_property( 'fillColor' );	find_property( 'strokeColor' );	find_property( 'strikeThroughColor' );	find_property( 'strikeThroughGapColor' );	find_property( 'underlineColor' );	find_property( 'underlineGapColor' );	return frames;		function find_property( prop ) {		app.findTextPreferences = NothingEnum.NOTHING;		app.findTextPreferences[ prop ] = swatch;		var found = app.activeDocument.findText();		for (var n = 0; n < found.length; n++) {			tframes = found[n].parentTextFrames;			if (tframes.length > 0) {				for (var m = 0; m < tframes.length; m++) {					spread = get_spread(tframes[m]);					frames.push( {thing: tframes[m], spread: spread.index});				}			} else { // Text steht im Übersatz				var f = found[n].parentStory.textContainers[ found[n].parentStory.textContainers.length-1 ] ;				spread = get_spread(f);				frames.push( {thing: f, spread: spread.index});				alert("Es wurde Text im Übersatz gefunden. Der letzte Rahmen des Textflusses wird markiert");			}		}	}}		function get_things( swatch, scope, spread_nr ) {	var things_in_scope = new Array();	if (scope.hasOwnProperty("pageItems") == false) {		return [];	}	var all_things = scope.pageItems;	for (var n = 0; n < all_things.length; n++) {		var thing = all_things[n];		if ( thing.hasOwnProperty("pageItems") && thing.pageItems.length > 0 ) {			var nested_things = get_things( swatch, thing, spread_nr);			for (var m = 0; m < nested_things.length; m++) {				things_in_scope.push(nested_things[m]);			}		}			// ------------------- Die eigentlichen Checks ----------		var is_one = false;		// ------------- Fill Color ----------		try {	// Gruppen haben keine Füllfarbe, können aber auch nicht abgefangen werden, weil thing ein pageItem ist			if ( thing.fillColor.id == swatch.id) {				is_one = true;			}		} catch(e) {}		// ------------- Stroke Color ----------		try {			if (thing.strokeColor.id == swatch.id) { 				is_one = true; 			}		} catch(e) {}		// ------------- Gap Color ----------		try {			if ( thing.gapColor.id == swatch.id) { 				is_one = true; 			}		} catch(e) {}		if (is_one == false) {			if (thing.transparencySettings.dropShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.transparencySettings.innerShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.transparencySettings.outerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.transparencySettings.innerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.transparencySettings.bevelAndEmbossSettings.highlightColor.id == swatch.id) { is_one = true; }			else if (thing.transparencySettings.bevelAndEmbossSettings.shadowColor.id == swatch.id) { is_one = true; }			else if (thing.transparencySettings.satinSettings.effectColor.id == swatch.id) { is_one = true; }		}		if (is_one == false && thing.fillTransparencySettings != undefined) {			if (thing.fillTransparencySettings.dropShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.fillTransparencySettings.innerShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.fillTransparencySettings.outerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.fillTransparencySettings.innerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.fillTransparencySettings.bevelAndEmbossSettings.highlightColor.id == swatch.id) { is_one = true; }			else if (thing.fillTransparencySettings.bevelAndEmbossSettings.shadowColor.id == swatch.id) { is_one = true; }			else if (thing.fillTransparencySettings.satinSettings.effectColor.id == swatch.id) { is_one = true; }		}		if (is_one == false && thing.strokeTransparencySettings != undefined) {			if (thing.strokeTransparencySettings.dropShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.strokeTransparencySettings.innerShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.strokeTransparencySettings.outerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.strokeTransparencySettings.innerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.strokeTransparencySettings.bevelAndEmbossSettings.highlightColor.id == swatch.id) { is_one = true; }			else if (thing.strokeTransparencySettings.bevelAndEmbossSettings.shadowColor.id == swatch.id) { is_one = true; }			else if (thing.strokeTransparencySettings.satinSettings.effectColor.id == swatch.id) { is_one = true; }		}		if (is_one == false && thing.contentTransparencySettings != undefined) {			if (thing.contentTransparencySettings.dropShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.contentTransparencySettings.innerShadowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.contentTransparencySettings.outerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.contentTransparencySettings.innerGlowSettings.effectColor.id == swatch.id) { is_one = true; }			else if (thing.contentTransparencySettings.bevelAndEmbossSettings.highlightColor.id == swatch.id) { is_one = true; }			else if (thing.contentTransparencySettings.bevelAndEmbossSettings.shadowColor.id == swatch.id) { is_one = true; }			else if (thing.contentTransparencySettings.satinSettings.effectColor.id == swatch.id) { is_one = true; }		}		if (is_one) {			things_in_scope.push({thing: thing, spread: spread_nr});		}	}	return things_in_scope;	}function indicate_object(thing, layer, swatch) {	var rec = app.activeDocument.spreads[thing.spread].rectangles.add( 		{			itemLayer: layer,			strokeColor: swatch,			strokeWeight: 2,			fillColor: app.activeDocument.swatches.item("None"),			geometricBounds: fix_gb( thing.thing.geometricBounds ) 		} 	);}function fix_gb( gb ) {	if ( gb.constructor.name == "Array" && gb.length == 4 ) {		return [			gb[0]-1,			gb[1]-1,			gb[2]+1,			gb[3]+1		];			} else {		return [ -1, -1, 1, 1 ];	}}function get_spread(theObj) {	var theSpread = theObj;	if (theSpread.hasOwnProperty("baseline")) {		theSpread = theSpread.parentTextFrames[0];		if (theSpread == null) {return undefined }	}	while (theSpread.constructor.name != "Spread") {		var whatIsIt = theSpread.constructor.name;		switch (whatIsIt) {			case  "Character" :				theSpread = theSpread.parentTextFrames[0];				break;			case "Application" :				// must be overset, so ignore (probably impossible)				return undefined;		}		theSpread = theSpread.parent;	}	return theSpread}